//#include "drivers.h"
//#include "common.h"


#include "drivers.h"
#include "common.h"
#include "tmath.h"

Terminal terminal;
Timer timer;

TI2C<'C', 0, 3> i2c;
SSD1315 oled;


uint32_t g_random_val;

uint32_t get_random()
{
    g_random_val = (uint32_t)1103515245*g_random_val + 12345;
    return g_random_val;
}


float pi_test(uint32_t iterations)
{
    float pi = 0.0f;
    float sgn = 1.0f;

    for (float i = 0.0f; i < (float)iterations; i+= 1.0f)
    {
        pi+= sgn*1.0f/(2.0f*i + 1.0f);
        sgn = -sgn;
    }

    pi = pi*4.0f;   

    return pi;
}

#define MAT_M       ((uint32_t)64)
#define MAT_N       ((uint32_t)64)   
#define MAT_K       ((uint32_t)64)


int16_t mat_a[MAT_M*MAT_K];
int16_t mat_b[MAT_K*MAT_N];
int32_t mat_c[MAT_M*MAT_N]; 


template <class DTypeY, class DTypeAB, unsigned int M, unsigned int N, unsigned int K>
void matmul(DTypeY *y, const DTypeAB *a, const DTypeAB *b, DTypeY *c)
{
    for (unsigned int m = 0; m < M; m++)
    {
        for (unsigned int n = 0; n < N; n++)
        {
            register DTypeY sum = 0; 
          

            const DTypeAB* rowA = &a[m * K];
            const DTypeAB* colB = &b[n];

            unsigned int k = 0;
            
            for (; k + 7 < K; k+= 8)
            {
                sum+= rowA[k + 0]*colB[(k + 0)*N];
                sum+= rowA[k + 1]*colB[(k + 1)*N];
                sum+= rowA[k + 2]*colB[(k + 2)*N];
                sum+= rowA[k + 3]*colB[(k + 3)*N];
                sum+= rowA[k + 4]*colB[(k + 4)*N];
                sum+= rowA[k + 5]*colB[(k + 5)*N];
                sum+= rowA[k + 6]*colB[(k + 6)*N];
                sum+= rowA[k + 7]*colB[(k + 7)*N];
            }
           

            for (; k < K; k++)      
            {
                sum+= rowA[k]*colB[k*N];
            }   

            y[m*N + n] = sum + c[m*N +n];
        }
    }
}


float matmul_test() 
{
    // fill matrix A
    for (unsigned int i = 0; i < (MAT_M*MAT_K); i++)
    {
        float v = (get_random()%1000000)/1000000.0f;
        v = v*100.0f;
        if (get_random()%2)
        {
            v = -v;
        }

        mat_a[i] = v;
    }

    // fill matrix B
    for (unsigned int i = 0; i < (MAT_K*MAT_N); i++)
    {
        float v = (get_random()%1000000)/1000000.0f;
        v = v*100.0f;
        if (get_random()%2)
        {
            v = -v;
        }

        mat_b[i] = v;
    }

    uint32_t time_start = timer.get_time();

    
    matmul<int32_t, int16_t, MAT_M, MAT_N, MAT_K>((int32_t*)mat_c, (int16_t*)mat_a, (int16_t*)mat_b, (int32_t*)mat_c);

    //matmul<int32_t, int8_t, MAT_M, MAT_N, MAT_K>((int32_t*)mat_c, (int8_t*)mat_a, (int8_t*)mat_b, (int32_t*)mat_c);
    //matmul<float, float, MAT_M, MAT_N, MAT_K>((float*)mat_c, (float*)mat_a, (float*)mat_b, (float*)mat_c);
    

    uint32_t time_stop = timer.get_time();

    uint32_t dt = time_stop - time_start;

    float macs = ((MAT_M*MAT_N*MAT_K)/(dt*0.001f));
    macs = macs/1000000.0f;
    return macs;
}






int main() 
{        
    drivers_init();  
    uart_init();

    terminal << "\n\nuart init done\n";
    

    timer.init();

  
    Gpio<'B', 0, GPIO_MODE_OUT> led_1;
    Gpio<'B', 7, GPIO_MODE_OUT> led_2;
    Gpio<'B', 14, GPIO_MODE_OUT> led_3;
    

    i2c.init();
    oled.init(i2c);
    

    while (1)
    {
        uint8_t v = (get_random() >> 8);

        if (v&(1<<0))
        {
            led_1 = 1;    
        }
        else
        {
            led_1 = 0;
        }

        if (v&(1<<1))
        {
            led_2 = 1;    
        }
        else
        {
            led_2 = 0;
        }

        if (v&(1<<2))
        {
            led_3 = 1;    
        }
        else
        {
            led_3 = 0;
        }
        
        uint32_t time = timer.get_time()/1000;

        uint32_t pi = pi_test(1000000)*100000000;

        float macs = matmul_test();

        terminal << "uptime = " << time << "\n";
        terminal << "pi  = " << pi << "\n";
        terminal << "macs  = " << macs << "\n";
        
        oled.put_info("uptime", time, 0);
        oled.put_info("pi", pi, 1);
        oled.put_info("macs", macs, 2);

        timer.delay_ms(500);
    }
    
    
    return 0;
}
